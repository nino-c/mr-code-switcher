--
-- PostgreSQL database dump
--

SET statement_timeout = 0;
SET lock_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;

SET search_path = public, pg_catalog;

SET default_tablespace = '';

SET default_with_oids = false;

--
-- Name: game_zeroplayergame; Type: TABLE; Schema: public; Owner: ninopq; Tablespace: 
--

CREATE TABLE game_zeroplayergame (
    id integer NOT NULL,
    title character varying(500) NOT NULL,
    description text NOT NULL,
    created timestamp with time zone NOT NULL,
    category_id integer NOT NULL,
    owner_id integer NOT NULL,
    "scriptType" character varying(100),
    source text NOT NULL,
    "seedStructure" text NOT NULL,
    "mainImage" character varying(255),
    parent_id integer,
    updated timestamp with time zone NOT NULL,
    popularity integer NOT NULL
);


ALTER TABLE public.game_zeroplayergame OWNER TO ninopq;

--
-- Name: game_plerpingapp_id_seq; Type: SEQUENCE; Schema: public; Owner: ninopq
--

CREATE SEQUENCE game_plerpingapp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.game_plerpingapp_id_seq OWNER TO ninopq;

--
-- Name: game_plerpingapp_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: ninopq
--

ALTER SEQUENCE game_plerpingapp_id_seq OWNED BY game_zeroplayergame.id;


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: ninopq
--

ALTER TABLE ONLY game_zeroplayergame ALTER COLUMN id SET DEFAULT nextval('game_plerpingapp_id_seq'::regclass);


--
-- Name: game_plerpingapp_id_seq; Type: SEQUENCE SET; Schema: public; Owner: ninopq
--

SELECT pg_catalog.setval('game_plerpingapp_id_seq', 37, true);


--
-- Data for Name: game_zeroplayergame; Type: TABLE DATA; Schema: public; Owner: ninopq
--

COPY game_zeroplayergame (id, title, description, created, category_id, owner_id, "scriptType", source, "seedStructure", "mainImage", parent_id, updated, popularity) FROM stdin;
25	Neenbox	Tests seed basics by allowing control over the color and size of the box.	2016-03-12 13:09:56.958477+00	7	1	text/javascript	var ctx = Canvas.getContext('2d')\nctx.fillStyle = color;\nctx.fillRect(10, 20, width, height);	{\n  "color":{"type":"color", "default":"#cccc00"},\n  "width":{"type":"number", "default":400},\n  "height":{"type":"number", "default":200}\n}		\N	2016-04-03 04:01:40.468342+00	1
4	Multivariate Polynomial Landscape	Choose coefficients of high-degree a polynomial function in 2 variables, as well as the 3x3 matrix used to project the graph of the surface onto a 2-dimensional canvas.  Many intricate and beautiful scenes emerge with certain affine transformations.  Defaults to a "standard" parallel projection of the z-axis (the axis "coming out of the screen")	2016-02-03 05:50:13.820034+00	2	1	text/paperscript	DARK_GREY = new Color(0.3, 0.3, 0.3, 0.8);\nLIGHT_GREY = new Color(0.9, 0.9, 0.9, 0.2);\nconsole.log(paper.Matrix)\nview.viewSize = new Size(Canvas.width, Canvas.height);\n\nx_axis = new Path({ strokeColor: DARK_GREY, strokeWidth: 0.3, strokeScaling: false });\nx_axis.add(new Point(-view.size.width/2, 0));\nx_axis.add(new Point(view.size.width/2, 0));\nx_axis.closed = true;\n//project.activeLayer.insertChild(0,x_axis)\n\ny_axis = new Path({ strokeColor: DARK_GREY, strokeWidth: 0.3, strokeScaling: false });\ny_axis.add(new Point(0, -view.size.height/2));\ny_axis.add(new Point(0, view.size.height/2));\n\nx_lines = [];\n_.each(_.range(-10,10), function(n) {\n    line = new Path({strokeColor: LIGHT_GREY });\n    line.add( new Point(n, view.size.height/2) );\n    line.add( new Point(n, -view.size.height/2) );\n    line.closed = true;\n    //project.activeLayer.insertChild(0, line);\n    x_lines.push( line );\n});\n\ny_lines = [];\n_.each(_.range(-10,10), function(n) {\n    line = new Path({strokeColor: LIGHT_GREY });\n    line.add( new Point(view.size.width/2, n) );\n    line.add( new Point(-view.size.width/2, n) );\n    line.closed = true;\n    //project.activeLayer.insertChild(0, line);\n    y_lines.push( line );\n});\n\nfunction transformToCartesian(lay) {\n    lay.transform( new Matrix((view.size.width / 10),0,0,(view.size.height / -10), view.center.x, view.center.y) );\n}\n\ntransformToCartesian(project.activeLayer);\n\n\n// define formal mathematical function\nMFunction = function(func, extrema) {\n    //console.log(func.length);\n    this.func = func;\n    if (!extrema) { extrema = [-5,5]; }\n\n    this.domain = {\n        elements: [],\n        min: (extrema[0] || -5),\n        max: (extrema[1] || 5)\n    };\n\n    this.codomain = {\n        elements: [],\n        min: null,\n        max: null\n    };\n\n    this.mapping = null;\n}\n\nMFunction.prototype = {\n    \n    compute: function(delta) {\n        if (!delta) { delta = 50; }\n        this.domain.elements = numeric.linspace(this.domain.min, this.domain.max, delta);\n        this.codomain.elements = _.map(this.domain.elements, this.func);\n        this.codomain.min = _.min(this.codomain.elements);\n        this.codomain.max = _.max(this.codomain.elements);\n        this.mapping = _.zip(this.domain.elements, this.codomain.elements);\n\n        this._w = Math.abs(this.domain.max - this.domain.min);\n        this._h = _.max(  [Math.abs(this.codomain.max),  Math.abs(this.codomain.min)]  );\n\n        this.transformation_matrix = new Matrix(\n            (view.size.width / this._w), 0,\n            0, (view.size.height / (-1*this._h)), \n            view.center.x, view.center.y);\n\n        this.computed = true;\n        console.log("computed")\n    },\n\n    // "flattens" mapping\n    // i.e. [[1,2],3] -> [1,2,3]\n    getPoints: function() {\n        if (!this.computed) { this.compute(); }\n        this.points = _.map(this.mapping, function(pair) {\n            return _.flatten(pair);\n        });\n        return this.points;\n    },\n\n\n    draw: function(path, matrix_premult, map3d, tmatrix) {\n\n        if (!this.computed) { this.compute(); }\n\n        if (map3d) {\n            this.points = this.points3d;\n        } else {\n            this.points = this.getPoints();\n        }\n\n        if (matrix_premult) {\n            this.points = _.map(this.points, function(p) {\n                return numeric.dot(matrix_premult, p);\n            })\n        }\n\n        _.each(this.points, function(p) {\n            path.add(new Point(p));\n        })\n\n        path.add(new Point(this.domain.max*2, Math.abs(this.codomain.min)*-5 + Math.abs(this.codomain.max)*-5));\n        path.add(new Point(this.domain.min*2, Math.abs(this.codomain.min)*-5 + Math.abs(this.codomain.max)*-5));\n        path.closed = true;\n\n        //path.transform(this.transformation_matrix);\n\n        //path.smooth();\n        \n        if (tmatrix) {\n            path.transform(tmatrix);\n        } else {\n            path.transform(this.transformation_matrix);\n        } \n    }\n}\n\n\nfunction CartesianProduct(A,B) {\n    prod = [];\n    _.each(A, function(a) {\n        _.each(B, function(b) {\n            prod.push([a,b]);\n        });\n    });\n    return prod;\n}\n\nBivariatePolynomialFunction = function(degree, vars, coeffs, roots) {\n\n\n    if (roots) {\n        // each set of roots must be <= degree in order\n        factorsSym = [];\n        _.each(roots[0], function(root) {\n            factorsSym.push("("+vars[0]+"-"+root.toString()+")")\n        });\n        _.each(roots[1], function(root) {\n            factorsSym.push("("+vars[1]+"-"+root.toString()+")")\n        });\n        latex = _.reduce(factorsSym, function(j,k) { return j.toString() + k.toString(); });\n\n        f = function(x,z) {\n            factors = [];\n            _.each(roots[0], function(root) {\n                factors.push( (x-root) );\n            });\n            _.each(roots[1], function(root) {\n                factors.push( (z-root) );\n            });\n            return _.reduce(factors, function(j,k) { return j*k; });\n        }\n        f.latex = "f("+vars[0]+", "+vars[1]+")=" +latex.split('--').join('+');\n        return f;\n\n    } else {\n\n        // num coeffs should be 1 less than degree-th triangular number\n        term_exps = _.filter(CartesianProduct(_.range(degree+1), _.range(degree+1)),\n            function(x) {\n                return (x[0] + x[1]) <= degree && (x[0] + x[1]) != 0;\n            });\n        \n        if (!coeffs) {\n            coeffs = _.map(_.range(term_exps.length), function(i) {\n                rand = (Math.random() * degree) - (degree/2);\n                if (Math.random() > .4) return 0;\n                return Math.round(rand*3);\n            });\n        }  \n        \n        terms_sym = _.map(term_exps, function(term, i) {\n            if (coeffs[i] == 0) return "";\n            if (coeffs[i] == 1) {\n                coeff = "";\n            } else if (coeffs[i] == -1) {\n                coeff = "-"\n            } else coeff = coeffs[i].toString();\n            return coeff + " "\n                + vars[0]+"^"+term[0].toString() + " "\n                + vars[1]+"^"+term[1].toString();\n        });\n        terms_sym = _.filter(terms_sym, function(x) { return x != ""; })\n        //console.log(terms_sym.join(" + "));\n\n        f = function(x,z) {\n            terms = _.map(term_exps, function(term, i) {\n                return coeffs[i] * Math.pow(x, term[0]) * Math.pow(z, term[1]);\n                });\n            return _.reduce(terms, function(j,k) { return j+k; });\n        }\n        f.latex = terms_sym.join("+").split("+-").join("-").split("+").join(" + ");\n        f.latex = f.latex.split("^1").join("");\n        f.latex = "f("+vars[0]+", "+vars[1]+")=" + f.latex.split(/[a-z]\\\\^0/).join("");\n        return f;\n    }\n\n}\n\n\n\n// choose a polynomial\n//Polynomial = new BivariatePolynomialFunction(3, ['x','y'], [1,-1,0,0,0,0,-2,3,1]);\n\nif (polynomial_degree === undefined) polynomial_degree = 5;\n\nPolynomial = new BivariatePolynomialFunction(polynomial_degree, ['x','y']);//, null, [[2,3,0,-7,0],[1,-2, -4, -13]]);\n\n\nslices = [];\nzrange = [-15,0];\nxrange = [-9, 9];\nzspace = numeric.linspace(zrange[0], zrange[1], 50);\n\nF0 = function(x) { return Polynomial(x,0); }\nslice0 = new MFunction(F0, [xrange[0],xrange[1]]);\nslice0.compute();\nglobal_matrix = slice0.transformation_matrix;\n\nCartesianMatrix = new Matrix(1,0,0,-1, view.center.x, view.center.y);\n\n// begin drawing process\nGraphLayer = new Layer({\n     blendMode: "multiply",\n});\n//GraphLayer.globalMatrix = CartesianMatrix;\n//GraphLayer.transform(CartesianMatrix);\n\nconsole.log("global matrix"); console.log(global_matrix);\n\nfunction_shown = false;\nzindex=0\n\nview.onFrame = function(event) {\n    \n    if (zindex < zspace.length) {\n        \n        //prevLayer = project.activeLayer;\n        l = new Layer({\n            //blendMode: "multiply"\n        });\n\n        z = zspace[zindex];\n        //console.log(z)\n    \n\n        F = function(x) { return Polynomial(x,z); }\n        slice = new MFunction(F, [xrange[0],xrange[1]]);\n\n        points3d = slice.getPoints();\n        _.each(_.range(points3d.length), function(i) { points3d[i].push(z); });\n\n        slice.points3d = points3d\n\n        transformation = [\n            [1, 0, 0], //5*Math.cos(Math.PI/-4)],\n            [0, 1, 0] //5*Math.sin(Math.PI/-4)],\n        ];\n\n        path1 = new Path({\n            strokeColor: new Color(0.3, 0.3, 0.3, 0.5),\n            strokeWidth: 1,\n            closed: true,\n            fillColor: new Color(Math.random(),1,Math.random(),0.2),\n        });\n\n        slice.draw(path1, transformation, true, global_matrix);\n        //path.transform(CartesianMatrix)\n\n        // transformation2 = new Matrix(\n        //     1-(z/50), 0, 0, 1-(z/50), 0, 0 //5*Math.sin(Math.PI/-4)],\n        // );\n\n        transformation2 = new Matrix(\n            1, 0, 0, 1, 0, 0 //5*Math.sin(Math.PI/-4)],\n        );\n\n        //path1.transform(transformation2);\n        path1.scale(1-(z/50), 1-(z/50), view.center)\n        path1.translate(new Point(-10*z, 30*z))\n        \n        project.activeLayer.insertChild(0,path1);\n\n        slices.push({layer: project.activeLayer,\n            func: slice,\n            transformation: transformation,\n            path: path1});\n\n        //console.log(path.position)\n        \n        if (zindex == zspace.length-1) { \n            //console.log(slices);\n            //view.pause();\n        }\n        zindex++;\n\n        if (!function_shown) {\n            if (display = document.getElementById("function-katex")) {\n                //katex.render(Polynomial.latex, display);\n                tokens = Polynomial.latex.split(" ");\n                line_length = Math.ceil(tokens.length/2);\n                line2 = tokens.splice(-1*line_length).join(" ");\n                line1 = tokens.join(" ");\n                $("#function-katex").text(\n                    "$$" + line1 + "$$\\\n$$\\\\\\\\space \\\\\\\\space \\\\\\\\space \\\\\\\\space " + line2 + "$$ \\\n"\n                     + "$$\\\\\\\\left(\\\\\\\\begin{array}{rrr}\\\n1 & 0 & \\\\\\\\frac{1}{2} \\\\\\\\, \\\\\\\\sqrt{2} \\\\\\\\\\\\\\\\\\\n0 & 1 & \\\\\\\\frac{1}{2} \\\\\\\\, \\\\\\\\sqrt{2}\\\\\\\\\\\\\\\\\\\n \\\\\\\\end{array}\\\\\\ight)$$");\n                function_shown = true;\n            }\n        }\n    }\n    \n}\n\n\n\n////////////\n\n\nfunction onResize(event) {\n\n}	{\n  "polynomial_degree": {"type":"number", "min":2, "max":20, "default": 5}\n}		\N	2016-03-23 10:38:51.626019+00	1
30	Audioviz Test	First test for audioviz components	2016-03-25 14:20:09.287348+00	4	1	text/paperscript	var N = 32; // should at least divide 1024\nvar analyser;\nvar viz;\n\n\n// create circle elements\nview.width = Canvas.width;\nview.height = Canvas.height;\n\nvar r = _.min([view.width, view.height]) / 2;\nvar elem = [];\n\n_.each(_.range(N), function(n) {\n\t\n\tvar rfac = ((N-n)/N); \n\t\n\tvar col = new Color();\n\tcol.hue = (360)*(n/N);\n\tcol.saturation = 0.5;\n\tcol.brightness = 1;\n\t\n\tvar el = new Path.Circle({\n\t\tradius: r*rfac,\n\t\tcenter: view.center,\n\t\tfillColor: col,\n\t\tblendMode: 'multiply',\n\t\topacity: 0.5 + ((n/N)/2)\n\t});\n\t\n\telem.push(el)\t\n})\n\n\nview.onFrame = function() {\n\t\n\tanalyser.getByteFrequencyData(fdata);\n\tconsole.log('onFrame');\n  \n\t_.each(elem, function(el, i){\n\t\t\n\t\tvar sum = 0;\n\t\t_.each(_.range( ((bincount/N)*i), ((bincount/N)*(i+1)) ), \n\t\t\tfunction(i) { sum += fdata[i]; });\n\t\t\n\t\tvar fac = ((sum/(bincount/N))/255);\n\n\t\tel.fillColor.saturation = fac;\n\t\tel.fillColor.hue += 3*fac;\n\n\n\t});\n\n}\n\n\nvar audio;\nvar bincount;\nvar fdata;\n\nwindow.start = function() {\n\t\n\taudio = new Audio();\n\taudio.src = '/static/audio/floyd.mp3';\n\taudio.play();\n\n\tvar ctx = new AudioContext();\n\tvar audioSrc = ctx.createMediaElementSource(audio);\n\tanalyser = ctx.createAnalyser();\n\taudioSrc.connect(analyser);\n\tanalyser.connect(ctx.destination);\n\n\tbincount = analyser.frequencyBinCount;\n\tfdata = new Uint8Array(bincount);\n}\n\nwindow.appdestroy = function() {\n\tconsole.log('app destroy');\n\taudio.pause();\n\taudio.src = '';\n    console.log(audio);\n\tdelete audio;\n\twindow.start = null;\n\tview.onFrame = null;\n}	{}	\N	\N	2016-04-03 21:47:37.358722+00	1
32	Transformations of grid about moving point	Transformations of grid about moving point	2016-04-04 08:58:04.510538+00	5	1	text/paperscript	view.viewSize = new Size(Canvas.width, Canvas.height);\n\n\nDARK_GREY = new Color(0.6, 0.6, 0.6, 0.5);\nLIGHT_GREY = new Color(0.7, 0.7, 0.7, 0.7);\n\nvar cartesian_matrix = new Matrix(1,0,0,-1, view.center.x, view.center.y);\ncartesian_matrix.scale(5)\nvar lines = [];\n\n_.each(_.range(-10,11), function(i) {\n\n\tvar path1 = new Path({\n\t\tstrokeWidth: 1,\n\t\tstrokeColor: DARK_GREY\n\t});\n\tvar points1 = _.map(_.range(-10,11), function(p) {\n\t\treturn new Point(p*10,i*10);\n\t});\n\t_.each(points1, function(p) {\n\t\tpath1.add(p);\n\t})\n\tlines.push(path1);\n\n})\n\n_.each(_.range(-10,11), function(i) {\n\n\tvar path2 = new Path({\n\t\tstrokeWidth: 1,\n\t\tstrokeColor: DARK_GREY\n\t});\n\tvar points2 = _.map(_.range(-10,11), function(p) {\n\t\treturn new Point(i*10,p*10);\n\t});\n\t_.each(points2, function(p) {\n\t\tpath2.add(p);\n\t})\n\tlines.push(path2);\n\n})\n\n\nproject.activeLayer.matrix = cartesian_matrix\n\n\n// connect points\n\n\n// rasterize never\n\n\n// var map = {\n// \tstring: '(x^2-i)(x+2)',\n// \ttransformation: function(x,y) {\n// \t\treturn new Point(Math.sin(x), - 2*Math.cos(y));\n// \t}\n// }\n\n\n// transform all points, see if points in both sets move ok\nvar transformation = new Matrix(1, 0, 0, 1, 0.01, -0.1);\ntransformation.rotate(0.1); \ntransformation.scale(0.99);\nconsole.log('trans', transformation)\n\nvar fixedpoint = (new Point(0,0)).transform(cartesian_matrix)\n//var radiusOfInversion = \n\nfunction applyTransform(seg,t) {\n\t//console.log(seg.point)\n\tvar vec = fixedpoint - seg.point\n\t//console.log(vec.length)\n\tif (vec.length != 0) {\n\t\tvec.angle += vec.length;\n\t\tseg.point = seg.point + (vec.normalize()*Math.cos(t/10))\n\t\t\n\t\t//console.log(fixedpoint)\n\t}\n\tvar r = 2; //Math.log(t)\n\tfixedpoint = (new Point(0,0) + new Point(r*Math.cos(t), \n\t\tr*Math.sin(t))).transform(cartesian_matrix);\n\tseg.path.smooth();\n}\n\nview.onFrame = function(e) {\n\t// e {delta, time, count}\n\t_.each(lines, function(line) {\n\t\t_.each(line.segments, function(seg) {\n\t\t\tapplyTransform(seg, e.time)\n\t\t\t//console.log(map.transformation(seg.point.x, seg.point.y))\n\t\t\t//seg.point = map.transformation(seg.point.x, seg.point.y);\n\t\t})\n\t})\n}	{"param1":{"default":""}}	\N	\N	2016-04-05 07:17:56.487936+00	1
24	2-dimensional Maze Generator and Solver	Uses DFS algorithm to create a unique maze each instance of running. Arrow keys let user navigate through and try to solve the maze. Automatic solving -- solution button presents the one and only one correct path.	2016-03-12 05:34:40.222228+00	1	1	text/javascript	/*\r\n\r\nMaze Generator pseudo-code\r\n\r\n1. Make the initial cell the current cell and mark it as visited\r\n2. While there are unvisited cells\r\n    1. If the current cell has any neighbors which have not been visited\r\n        1. Choose randomly one of the unvisited neighbors\r\n        2. Push the chosen cell to the stack\r\n        3. Remove the wall between the current cell and the chosen cell\r\n        4. Make the chosen cell the current cell and mark it as visited\r\n    2. Otherwise\r\n        1. Pop a cell from the stack\r\n        2. Make it the current cell\r\n*/\r\n\r\n// class Maze {\r\n\r\nfunction Maze(dimension, x, y, cellSize) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.map = [];\r\n    this.visited = [];\r\n    this.stack = [];\r\n    this.cellSize = cellSize;\r\n    this.begin = [];\r\n    this.turnArounds = [];\r\n    this.currentPosition = [0, 0];\r\n    this.ballRadius = this.cellSize * 0.4;\r\n    this.linesDrawn = [];\r\n\r\n    for (var i=0; i<y; i++) {\r\n        this.map.push( [] );\r\n        this.visited.push( [] );\r\n        for (var j=0; j<x; j++) {\r\n            this.map[i].push( [1,1,1,1] );\r\n            this.visited[i].push( false );\r\n        }\r\n    }\r\n\r\n    this.generateMap();\r\n}\r\n\r\nMaze.prototype.unvisitedCellsExist = function() {\r\n    for (var i=0; i<this.y; i++) {\r\n        for (var j=0; j<this.x; j++) {\r\n            if (this.visited[i][j]) return true;\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\nMaze.prototype.chooseNeighbor = function(cx,cy) {\r\n    var neighbors = [];\r\n    var directions = [];\r\n    if (cx > 0 && !this.visited[cy][cx-1]) \r\n        { neighbors.push( [cx-1, cy] ); directions.push('W'); }\r\n    if (cx < this.x-1 && !this.visited[cy][cx+1]) \r\n        { neighbors.push( [cx+1, cy] ); directions.push('E'); }\r\n    if (cy < this.y-1 && !this.visited[cy+1][cx]) \r\n        { neighbors.push( [cx, cy+1] ); directions.push('S'); }\r\n    if (cy > 0 && !this.visited[cy-1][cx]) \r\n        { neighbors.push( [cx, cy-1] ); directions.push('N'); }\r\n    if (neighbors.length) {\r\n        r = Math.floor(Math.random()*neighbors.length);\r\n        return [ neighbors[r], directions[r] ];\r\n    } else return false;\r\n};\r\n\r\nMaze.prototype.removeWall = function(x1, y1, direction) { \r\n    switch (direction) {\r\n        case 'N':\r\n            this.map[y1][x1][0] = 0;\r\n            this.map[y1-1][x1][2] = 0;\r\n        break;\r\n        case 'E':\r\n            this.map[y1][x1][1] = 0;\r\n            this.map[y1][x1+1][3] = 0;\r\n        break;\r\n        case 'S':\r\n            this.map[y1][x1][2] = 0;\r\n            this.map[y1+1][x1][0] = 0;\r\n        break;\r\n        case 'W':\r\n            this.map[y1][x1][3] = 0;\r\n            this.map[y1][x1-1][1] = 0;\r\n        break;\r\n    }\r\n};\r\n\r\nMaze.prototype.generateMap = function() {\r\n    \r\n    // choose initial cell\r\n    var rx = Math.floor(Math.random()*this.x);\r\n    var ry = Math.floor(Math.random()*this.y);\r\n\r\n    this.begin = [rx, ry];\r\n\r\n    var cx = rx;\r\n    var cy = ry;\r\n    var nx;\r\n    var ny;\r\n\r\n    this.visited[cy][cx] = true;\r\n\r\n    var next;\r\n    var nextDirection;\r\n\r\n    // while there are still unvisited cells\r\n    while (this.unvisitedCellsExist()) {\r\n        if (this.chooseNeighbor(cx,cy)) {\r\n            \r\n            next = this.chooseNeighbor(cx,cy);\r\n            \r\n            nx = next[0][0];\r\n            ny = next[0][1];\r\n            \r\n            nextDirection = next[1];\r\n            this.stack.push( [nx, ny] );\r\n            this.removeWall(cx, cy, nextDirection);\r\n            this.visited[ny][nx] = true;\r\n\r\n            cx = nx;\r\n            cy = ny;\r\n        \r\n        } else if (this.stack.length) {\r\n\r\n            next = this.stack.pop();\r\n            cx = next[0];\r\n            cy = next[1];\r\n            this.turnArounds.push([cx, cy]);\r\n          \r\n        } else break;\r\n    }\r\n\r\n    this.end = [cx, cy];\r\n    this.map[0][0][3] = 0;\r\n    this.map[this.y-1][this.x-1][1] = 0;\r\n\r\n};\r\n\r\nMaze.prototype.getClearRect = function(cx, cy) {\r\n    var fx = cx * this.cellSize + (this.cellSize/2) - (this.ballRadius) - 1;\r\n    var fy = cy * this.cellSize + (this.cellSize/2) - (this.ballRadius) - 1;\r\n    return [fx,fy];\r\n};\r\n\r\nMaze.prototype.getBallCoords = function(nx, ny) {\r\n    var bx = nx * this.cellSize + (this.cellSize/2);\r\n    var by = ny * this.cellSize + (this.cellSize/2);\r\n    return [bx,by];\r\n};\r\n\r\nMaze.prototype.clearBall = function() {\r\n    var cl = this.getClearRect(this.currentPosition[0], this.currentPosition[1]);\r\n    ctx.clearRect(cl[0], cl[1], this.ballRadius*2+2, this.ballRadius*2+2);\r\n};\r\n\r\nMaze.prototype.drawBall = function() {\r\n    var ballCoords = this.getBallCoords(this.currentPosition[0], this.currentPosition[1]);\r\n    ctx.beginPath();\r\n    ctx.arc(ballCoords[0], ballCoords[1], this.ballRadius, 0, 2*Math.PI, false);\r\n    ctx.fillStyle = 'green';\r\n    ctx.fill();\r\n    ctx.lineWidth = 1;\r\n    ctx.strokeStyle = '#003300';\r\n    ctx.stroke();\r\n};\r\n\r\nMaze.prototype.move = function(d) {\r\n    var dx = d[0];\r\n    var dy = d[1];\r\n    this.clearBall();\r\n    this.currentPosition = [this.currentPosition[0]+dx, this.currentPosition[1]+dy];\r\n    this.drawBall();\r\n};\r\n\r\nMaze.prototype.lineIsDrawn = function(mt, lt) {\r\n    for (var i=0; i<this.linesDrawn.length; i++) {\r\n        if (this.linesDrawn[i][0][0] == mt[0] &&\r\n            this.linesDrawn[i][0][1] == mt[1] &&\r\n            this.linesDrawn[i][1][0] == lt[0] &&\r\n            this.linesDrawn[i][1][1] == lt[1]) {\r\n\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\nMaze.prototype.render = function(ctx) {\r\n    \r\n    var cell;\r\n    var cx;\r\n    var cy;\r\n\r\n    ctx.moveTo(0,0);\r\n    ctx.lineWidth = 1;\r\n    ctx.strokeStyle = '#666666';\r\n    \r\n    for (var i=0; i<this.y; i++) {\r\n        for (var j=0; j<this.x; j++) {\r\n            \r\n            ctx.beginPath();\r\n            cell = this.map[i][j];\r\n            cx = this.cellSize * j;\r\n            cy = this.cellSize * i;\r\n            var mt;\r\n            var lt;\r\n\r\n            if (cell[0]) {\r\n                mt = [cx, cy];\r\n                lt = [cx+this.cellSize, cy];\r\n                if (!this.lineIsDrawn(mt, lt)) {\r\n                    this.linesDrawn.push([mt, lt]);\r\n                    ctx.moveTo(mt[0], mt[1]);\r\n                    ctx.lineTo(lt[0], lt[1]);\r\n                    ctx.stroke();\r\n                }\r\n            } \r\n            if (cell[1]) {\r\n                mt = [cx+this.cellSize, cy];\r\n                lt = [cx+this.cellSize, cy+this.cellSize];\r\n                if (!this.lineIsDrawn(mt, lt)) {\r\n                    this.linesDrawn.push([mt, lt]);\r\n                    ctx.moveTo(mt[0], mt[1]);\r\n                    ctx.lineTo(lt[0], lt[1]);\r\n                    ctx.stroke();\r\n                }\r\n            } \r\n            if (cell[2]) {\r\n                mt = [cx+this.cellSize, cy+this.cellSize];\r\n                lt = [cx, cy+this.cellSize];\r\n                if (!this.lineIsDrawn(mt, lt)) {\r\n                    this.linesDrawn.push([mt, lt]);\r\n                    ctx.moveTo(mt[0], mt[1]);\r\n                    ctx.lineTo(lt[0], lt[1]);\r\n                    ctx.stroke();\r\n                }\r\n            }\r\n            if (cell[3]) {\r\n                mt = [cx, cy+this.cellSize];\r\n                lt = [cx, cy];\r\n                if (!this.lineIsDrawn(mt, lt)) {\r\n                    this.linesDrawn.push([mt, lt]);\r\n                    ctx.moveTo(mt[0], mt[1]);\r\n                    ctx.lineTo(lt[0], lt[1]);\r\n                    ctx.stroke();\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    this.move([0,0]);\r\n\r\n};\r\n\r\n// } end class Maze\r\n\r\n/*\r\n    MazeSolver pseudo-code\r\n\r\n    1. start at the entrance\r\n    2. while not at the exit\r\n        1. push the current cell to visited\r\n        2. if exists one or more directions that have not been visited\r\n            1. push the current cell to pathStack\r\n            2. choose any direction from those not visited\r\n            3. move in that direction\r\n            4. draw path from previous cell to chosen cell\r\n            5. make the chosen cell the current cell\r\n        3. otherwise backtrack\r\n            1. pop the pathStack\r\n            2. remove line from currentCell to popped cell\r\n            3. do not remove popped cell from visited\r\n*/\r\n\r\n// class MazeSolver {\r\n\r\nfunction MazeSolver(maze) {\r\n    this.Maze = maze;\r\n    this.position = [0, 0];\r\n    this.pathStack = [];\r\n    this.visited = [];\r\n    this.Maze.clearBall();\r\n\r\n    var self = this;\r\n    this.solveStep = function() {\r\n        self.moveForward();\r\n    };\r\n}\r\n\r\nMazeSolver.prototype.getValidDirections = function(x,y) {\r\n    \r\n    var directions = [];\r\n    \r\n    if (!this.Maze.map[y][x][0]) \r\n        directions.push([0,-1]);\r\n    if (!this.Maze.map[y][x][1] && (x!=this.Maze.x-1 || y!=this.Maze.y-1)) \r\n        directions.push([1,0]);\r\n    if (!this.Maze.map[y][x][2]) \r\n        directions.push([0,1]);\r\n    if (!this.Maze.map[y][x][3] && (x||y)) \r\n        directions.push([-1,0]);\r\n\r\n    var validDirections = [];\r\n    for (var i=0; i<directions.length; i++) {\r\n        var tx = x+directions[i][0];\r\n        var ty = y+directions[i][1];\r\n        if (!this.isVisited(tx,ty)) {\r\n            validDirections.push(directions[i]);\r\n        }\r\n    }\r\n\r\n    return validDirections;\r\n};\r\n\r\nMazeSolver.prototype.isVisited = function(x,y) {\r\n    for (var i=0; i<this.visited.length; i++) {\r\n        if (this.visited[i][0] == x && this.visited[i][1] == y) \r\n            return true;\r\n    }\r\n    return false;\r\n};\r\n\r\nMazeSolver.prototype.isDeadEnd = function(x,y) {\r\n    if (!this.getValidDirections(x,y).length)\r\n        return true;\r\n    return false;\r\n};\r\n\r\nMazeSolver.prototype.movePath = function(cx,cy,nx,ny) {\r\n    ctx.lineWidth = 4;\r\n    ctx.strokeStyle = solutionPathColor;\r\n    ctx.beginPath();\r\n\r\n    ctx.moveTo(cx*this.Maze.cellSize+this.Maze.cellSize/2, \r\n        cy*this.Maze.cellSize+this.Maze.cellSize/2);\r\n    ctx.lineTo(nx*this.Maze.cellSize+this.Maze.cellSize/2, \r\n        ny*this.Maze.cellSize+this.Maze.cellSize/2);\r\n    ctx.stroke();\r\n};\r\n\r\nMazeSolver.prototype.clearPath = function(x,y) {\r\n    ctx.clearRect(x*this.Maze.cellSize+2, y*this.Maze.cellSize+2, \r\n        this.Maze.cellSize-4, this.Maze.cellSize-4);\r\n};\r\n\r\nMazeSolver.prototype.isFinished = function() {\r\n    if (this.position[0] == this.Maze.x-1 && this.position[1] == this.Maze.y-1)\r\n        return true;\r\n    return false;\r\n};\r\n\r\nMazeSolver.prototype.moveForward = function() {\r\n    \r\n    var cx = this.position[0];\r\n    var cy = this.position[1];\r\n    \r\n    this.visited.push([cx,cy]);\r\n    \r\n    if (this.isFinished()) {\r\n        console.log("FINISH");\r\n        clearInterval(this.interval);\r\n        return;\r\n    }\r\n\r\n    if (!this.isDeadEnd(cx,cy)) {\r\n        this.pathStack.push([cx,cy]);\r\n        var directions = this.getValidDirections(cx,cy);\r\n        var randomDirection = Math.floor(Math.random()*directions.length);\r\n        \r\n        var nx = cx + directions[randomDirection][0];\r\n        var ny = cy + directions[randomDirection][1];\r\n\r\n        this.movePath(cx,cy,nx,ny);\r\n        this.position = [nx,ny];\r\n\r\n    } else { \r\n        this.backtrack();\r\n    }\r\n};\r\n\r\nMazeSolver.prototype.backtrack = function() {\r\n    var lastCell = this.pathStack.pop();\r\n    this.clearPath(this.position[0], this.position[1]);\r\n    this.position = [lastCell[0], lastCell[1]];\r\n};\r\n\r\n// } end class MazeSolver\r\n\r\n\r\n\r\n\r\nfunction solveMaze() {\r\n    solver = new MazeSolver(Maze);\r\n    solver.interval = setInterval(solver.solveStep, 5);\r\n}\r\n\r\nvar Maze;\r\nvar ctx = Canvas.getContext("2d");\r\nvar solver;\r\n\r\nctx.fillStyle = '#ffffff'\r\nctx.fillRect(0,0,Canvas.width, Canvas.height)\r\n\r\n\r\n\r\nvar mx = Math.floor((Canvas.width) / cellSize);\r\nvar my = Math.floor((Canvas.height) / cellSize);\r\n\r\nconsole.log([Canvas.height, $(window).height(), mx, my]);\r\n\r\nMaze = new Maze(2, mx, my, cellSize);\r\nMaze.render(ctx);\r\n\r\n$(window).keydown(function(e) {\r\n            \r\n    var tx = Maze.currentPosition[0];\r\n    var ty = Maze.currentPosition[1];\r\n\r\n    switch (e.keyCode) {\r\n\r\n        case 37: // left\r\n            if (!Maze.map[ty][tx][3]) Maze.move([-1,0]);\r\n        break;\r\n        case 38: // up\r\n            if (!Maze.map[ty][tx][0]) Maze.move([0,-1]);\r\n        break;\r\n        case 39: // right\r\n            if (!Maze.map[ty][tx][1]) Maze.move([1,0]);\r\n        break;\r\n        case 40: // down\r\n            if (!Maze.map[ty][tx][2]) Maze.move([0,1]);\r\n        break;\r\n        case 83: // 's' key\r\n            solver = new MazeSolver(Maze);\r\n            solver.interval = setInterval(solver.solveStep, 5);\r\n        break;\r\n\r\n    }\r\n});\r\n\r\nwindow.appdestroy = function() {\r\n\t$(window).unbind('keydown');\r\n  \tclearInterval(solver.interval);\r\n  \tdelete Maze;\r\n  \tdelete solver;\r\n}	{\r\n    "cellSize": {"type": "number", "min": 5, "max": 150, "default": 30},\r\n    "solutionPathColor": {"type": "color", "default": "#cc0055"}\r\n}		\N	2016-04-09 17:56:13.369187+00	70
5	Function in 1 var, time parameter, and contour	Sets of graphs of a function in 1 variable with time as a parameter.  (Technically a function in 2 variables)	2016-02-03 03:11:30.899129+00	5	1	text/paperscript	/*\r\n    *\r\n    *   @author: nino p cocchiarella\r\n    *   (c) 2016\r\n    *\r\n*/\r\n\r\nview.viewSize = new Size(Canvas.width, Canvas.height);\r\n\r\n// define formal mathematical function in 1 var\r\nMFunction = function(func, extrema) {\r\n   \r\n    this.func = func;\r\n    if (!extrema) { extrema = [-5,5]; }\r\n\r\n    this.domain = {\r\n        elements: [],\r\n        min: (extrema[0] || -5),\r\n        max: (extrema[1] || 5)\r\n    };\r\n\r\n    this.codomain = {\r\n        elements: [],\r\n        min: null,\r\n        max: null\r\n    };\r\n\r\n    this.mapping = null;\r\n    this.compute();\r\n}\r\n\r\nMFunction.prototype = {\r\n    \r\n    compute: function(delta) {\r\n        if (!delta) { delta = 100; }\r\n\r\n        eval("_func = function(x) { return "+this.func+"; };");\r\n\r\n        this.domain.elements = numeric.linspace(this.domain.min, this.domain.max, delta);\r\n        this.codomain.elements = _.map(this.domain.elements, _func);\r\n        this.codomain.min = _.min(this.codomain.elements);\r\n        this.codomain.max = _.max(this.codomain.elements);\r\n        this.mapping = _.zip(this.domain.elements, this.codomain.elements);\r\n    },\r\n\r\n    draw: function(path, matrix_premult) {\r\n        if (this.mapping == null) { this.compute(); }\r\n        \r\n        _w = Math.abs(this.domain.max - this.domain.min);\r\n        _h = _.max(  [Math.abs(this.codomain.max),  Math.abs(this.codomain.min)]  );\r\n    \r\n\r\n        points = this.mapping;\r\n\r\n        if (matrix_premult) {\r\n            points = _.map(points, function(p) {\r\n                return numeric.dot(matrix_premult, p);\r\n            })\r\n        }\r\n\r\n        _.each(points, function(p) {\r\n            path.add(new Point(p));\r\n        });\r\n        \r\n        T = new Matrix(\r\n            (view.size.width / _w), 0,\r\n            0, (view.size.height / (-1*_h)), \r\n            view.center.x, view.center.y);\r\n\r\n        project.activeLayer.transform(T); \r\n    }\r\n}\r\n\r\nvar func = new MFunction(funct.javascript, [xMin,xMax]);\r\n\r\n// draw Cartesian axes\r\ndrawAxes = function(xmax, ymax) {\r\n\r\n    if (xmax == undefined) xmax = 10;\r\n    if (ymax == undefined) ymax = 10;\r\n\r\n    DARK_GREY = new Color(0.3, 0.3, 0.3, 0.8);\r\n    LIGHT_GREY = new Color(0.9, 0.9, 0.9, 0.2);\r\n\r\n    x_axis = new Path({ strokeColor: DARK_GREY, strokeWidth: 0.3, strokeScaling: false });\r\n    x_axis.add(new Point(-view.size.width/2, 0));\r\n    x_axis.add(new Point(view.size.width/2, 0));\r\n\r\n    y_axis = new Path({ strokeColor: DARK_GREY, strokeWidth: 0.3, strokeScaling: false });\r\n    y_axis.add(new Point(0, -view.size.height/2));\r\n    y_axis.add(new Point(0, view.size.height/2));\r\n\r\n    _.each(_.range(-1*xmax,xmax), function(n) {\r\n        var line = new Path({strokeColor: LIGHT_GREY });\r\n        line.add( new Point(n, view.size.height/2) );\r\n        line.add( new Point(n, -view.size.height/2) );\r\n        line.closed = true;\r\n    });\r\n\r\n\r\n    _.each(_.range(-1*ymax,ymax), function(n) {\r\n        var line = new Path({strokeColor: LIGHT_GREY });\r\n        line.add( new Point(view.size.width/2, n) );\r\n        line.add( new Point(-view.size.width/2, n) );\r\n        line.closed = true;\r\n    });\r\n\r\n\r\n    project.activeLayer.transform( new Matrix((view.size.width / xmax),0,0,(view.size.height / (-1*ymax)), view.center.x, view.center.y) );\r\n\r\n}\r\n//executeRemotePaperscript("/static/site/js/app/graph-util.js");\r\ndrawAxes();\r\n\r\n////////////////////////\r\n\r\nINITCOLOR = _.map(_.range(3), Math.random)\r\nN = 15;\r\n\r\n\r\ngraphs = [];\r\n\r\n_.map(_.range(N), function(n) {\r\n\r\n    layer = new Layer({\r\n        backgroundColor: new Color(1,1,1,0)\r\n    });\r\n\r\n    thickness = (n == 0 ? 3 : 1)\r\n    alpha = 0.5 - (n/(N*2))\r\n\r\n    var graph = new Path({\r\n        strokeColor: new Color(  INITCOLOR.concat([alpha]) ),\r\n        strokeWidth: thickness\r\n    });\r\n\r\n    matrix = [[1,0],[0,(1-(n/N))]]\r\n    func.draw(graph, matrix);\r\n    graph.smooth();\r\n    graphs.push(graph);\r\n\r\n });\r\n\r\n\r\n\r\n\r\n////////////\r\n\r\n\r\nfunction onResize(event) {\r\n\r\n}\r\n\r\nview.onFrame = function(event) {\r\n    scale = 1 + (Math.sin(event.time)/ breathDelta)\r\n    _.each(graphs, function(g) {\r\n        g.scale(1, scale);\r\n    });\r\n}\r\n\r\nwindow.onDestroy = function() {\r\n\tproject.layers.forEach(function(lay) {\r\n\t\tlay.remove();\r\n\t}); \r\n}	{\r\n    "breathDelta": {"type": "number", "default":17, "min":1.1, "max":1000},\r\n    "funct": {"type": "math", "default": "cos(2x) + x^5"},\r\n    "xMin": {"type": "number", "default": -5},\r\n    "xMax": {"type": "number", "default": 5}\r\n}		\N	2016-04-09 17:56:51.999249+00	50
2	3-dimensional "Wolfenstein" Maze Generator	Generates a unique random 3-dimensional maze each instance. Allows user to navigate through maze with old-fashioned "Wolfenstein"-style interface. Collision detection built in.	2016-02-04 08:16:14.056506+00	1	1	text/javascript	/*\r\n\r\nMaze Generator pseudo-code\r\n\r\n1. Make the initial cell the current cell and mark it as visited\r\n2. While there are unvisited cells\r\n    1. If the current cell has any neighbors which have not been visited\r\n        1. Choose randomly one of the unvisited neighbors\r\n        2. Push the chosen cell to the stack\r\n        3. Remove the wall between the current cell and the chosen cell\r\n        4. Make the chosen cell the current cell and mark it as visited\r\n    2. Otherwise\r\n        1. Pop a cell from the stack\r\n        2. Make it the current cell\r\n*/\r\n\r\n// class Maze {\r\n\r\nfunction Maze(dimension, x, y, cellSize) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.map = [];\r\n    this.visited = [];\r\n    this.stack = [];\r\n    this.cellSize = cellSize;\r\n    this.begin = [];\r\n    this.turnArounds = [];\r\n    this.currentPosition = [0, 0];\r\n    this.ballRadius = this.cellSize * 0.4;\r\n    this.wallsRendered = [];\r\n    this.grass;\r\n    this.sky;\r\n    this.collisionPadding = 20;\r\n    this.playerCurrentCell = [0, 0];\r\n    this.atWall = false;\r\n    this.directionUnlocked = 0;\r\n    this.approachQuadrant = 0;\r\n\r\n    for (var i=0; i<y; i++) {\r\n        this.map.push( [] );\r\n        this.visited.push( [] );\r\n        for (var j=0; j<x; j++) {\r\n            this.map[i].push( [1,1,1,1] );\r\n            this.visited[i].push( false );\r\n        }\r\n    }\r\n\r\n    this.generateMap();\r\n}\r\n\r\nMaze.prototype.unvisitedCellsExist = function() {\r\n    for (var i=0; i<this.y; i++) {\r\n        for (var j=0; j<this.x; j++) {\r\n            if (this.visited[i][j]) return true;\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\nMaze.prototype.chooseNeighbor = function(cx,cy) {\r\n    var neighbors = [];\r\n    var directions = [];\r\n    if (cx > 0 && !this.visited[cy][cx-1]) \r\n        { neighbors.push( [cx-1, cy] ); directions.push('W'); }\r\n    if (cx < this.x-1 && !this.visited[cy][cx+1]) \r\n        { neighbors.push( [cx+1, cy] ); directions.push('E'); }\r\n    if (cy < this.y-1 && !this.visited[cy+1][cx]) \r\n        { neighbors.push( [cx, cy+1] ); directions.push('S'); }\r\n    if (cy > 0 && !this.visited[cy-1][cx]) \r\n        { neighbors.push( [cx, cy-1] ); directions.push('N'); }\r\n    if (neighbors.length) {\r\n        r = Math.floor(Math.random()*neighbors.length);\r\n        return [ neighbors[r], directions[r] ];\r\n    } else return false;\r\n};\r\n\r\nMaze.prototype.removeWall = function(x1, y1, direction) { \r\n    switch (direction) {\r\n        case 'N':\r\n            this.map[y1][x1][0] = 0;\r\n            this.map[y1-1][x1][2] = 0;\r\n        break;\r\n        case 'E':\r\n            this.map[y1][x1][1] = 0;\r\n            this.map[y1][x1+1][3] = 0;\r\n        break;\r\n        case 'S':\r\n            this.map[y1][x1][2] = 0;\r\n            this.map[y1+1][x1][0] = 0;\r\n        break;\r\n        case 'W':\r\n            this.map[y1][x1][3] = 0;\r\n            this.map[y1][x1-1][1] = 0;\r\n        break;\r\n    }\r\n};\r\n\r\nMaze.prototype.generateMap = function() {\r\n    \r\n    // choose initial cell\r\n    var rx = Math.floor(Math.random()*this.x);\r\n    var ry = Math.floor(Math.random()*this.y);\r\n\r\n    this.begin = [rx, ry];\r\n\r\n    var cx = rx;\r\n    var cy = ry;\r\n    var nx;\r\n    var ny;\r\n\r\n    this.visited[cy][cx] = true;\r\n\r\n    var next;\r\n    var nextDirection;\r\n\r\n    // while there are still unvisited cells\r\n    while (this.unvisitedCellsExist()) {\r\n        if (this.chooseNeighbor(cx,cy)) {\r\n            \r\n            next = this.chooseNeighbor(cx,cy);\r\n            \r\n            nx = next[0][0];\r\n            ny = next[0][1];\r\n            \r\n            nextDirection = next[1];\r\n            this.stack.push( [nx, ny] );\r\n            this.removeWall(cx, cy, nextDirection);\r\n            this.visited[ny][nx] = true;\r\n\r\n            cx = nx;\r\n            cy = ny;\r\n        \r\n        } else if (this.stack.length) {\r\n\r\n            next = this.stack.pop();\r\n            cx = next[0];\r\n            cy = next[1];\r\n            this.turnArounds.push([cx, cy]);\r\n          \r\n        } else break;\r\n    }\r\n\r\n    this.end = [cx, cy];\r\n    this.map[0][0][3] = 0;\r\n    this.map[this.y-1][this.x-1][1] = 0;\r\n\r\n};\r\n\r\nMaze.prototype.getClearRect = function(cx, cy) {\r\n    var fx = cx * this.cellSize + (this.cellSize/2) - (this.ballRadius) - 1;\r\n    var fy = cy * this.cellSize + (this.cellSize/2) - (this.ballRadius) - 1;\r\n    return [fx,fy];\r\n};\r\n\r\nMaze.prototype.getBallCoords = function(nx, ny) {\r\n    var bx = nx * this.cellSize + (this.cellSize/2);\r\n    var by = ny * this.cellSize + (this.cellSize/2);\r\n    return [bx,by];\r\n};\r\n\r\nMaze.prototype.clearBall = function() {\r\n    var cl = this.getClearRect(this.currentPosition[0], this.currentPosition[1]);\r\n    ctx.clearRect(cl[0], cl[1], this.ballRadius*2+2, this.ballRadius*2+2);\r\n};\r\n\r\nMaze.prototype.drawBall = function() {\r\n    var ballCoords = this.getBallCoords(this.currentPosition[0], this.currentPosition[1]);\r\n    ctx.beginPath();\r\n    ctx.arc(ballCoords[0], ballCoords[1], this.ballRadius, 0, 2*Math.PI, false);\r\n    ctx.fillStyle = 'green';\r\n    ctx.fill();\r\n    ctx.lineWidth = 1;\r\n    ctx.strokeStyle = '#003300';\r\n    ctx.stroke();\r\n};\r\n\r\nMaze.prototype.move = function(d) {\r\n    var dx = d[0];\r\n    var dy = d[1];\r\n    this.clearBall();\r\n    this.currentPosition = [this.currentPosition[0]+dx, this.currentPosition[1]+dy];\r\n    this.drawBall();\r\n};\r\n\r\nMaze.prototype.wallIsRendered = function(mt, lt) {\r\n    for (var i=0; i<this.wallsRendered.length; i++) {\r\n        if (this.wallsRendered[i][0][0] == mt[0] &&\r\n            this.wallsRendered[i][0][1] == mt[1] &&\r\n            this.wallsRendered[i][1][0] == lt[0] &&\r\n            this.wallsRendered[i][1][1] == lt[1]) {\r\n\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\nMaze.prototype.getQuadrant = function(theta) {\r\n    if (theta <= (Math.PI/2)) return 1;\r\n    if (theta <= Math.PI) return 2;\r\n    if (theta <= (Math.PI*3)/2) return 3;\r\n    if (theta <= (Math.PI*2)) return 4;\r\n}\r\n\r\nMaze.prototype.getOppositeQuad = function(quad) {\r\n    if (quad == 1) return 3;\r\n    if (quad == 2) return 4;\r\n    if (quad == 3) return 1;\r\n    if (quad == 4) return 2;\r\n}\r\n\r\nMaze.prototype.isDirectionValid = function(direction) {\r\n    \r\n    var currentAngle = (((Math.PI*3)/2) - camera.rotation.y) % (2*Math.PI);\r\n    if (currentAngle < 0) currentAngle += (2*Math.PI);\r\n    var currentQuad = this.getQuadrant(currentAngle);\r\n\r\n    // if at a wall, handle wall vs. direction, then return false\r\n    if (this.atWall) {\r\n\r\n        switch (this.atWall) {\r\n            case 'N':\r\n                if ((currentQuad == 3 || currentQuad == 4) && direction == 1)\r\n                    return true;\r\n                if ((currentQuad == 1 || currentQuad == 2) && direction == -1)\r\n                    return true;\r\n                if (currentQuad == 1)\r\n                    camera.position.x += 10;\r\n                if (currentQuad == 2)\r\n                    camera.position.x -= 10;\r\n                return false;\r\n            break;\r\n            case 'E':\r\n                if ((currentQuad == 2 || currentQuad == 3) && direction == 1)\r\n                    return true;\r\n                if ((currentQuad == 1 || currentQuad == 4) && direction == -1)\r\n                    return true;\r\n                if (currentQuad == 1)\r\n                    camera.position.z -= 10;\r\n                if (currentQuad == 4)\r\n                    camera.position.z += 10;\r\n                return false;\r\n            break;\r\n            case 'S':\r\n                if ((currentQuad == 1 || currentQuad == 2) && direction == 1)\r\n                    return true;\r\n                if ((currentQuad == 3 || currentQuad == 4) && direction == -1)\r\n                    return true;\r\n                if (currentQuad == 3)\r\n                    camera.position.x -= 10;\r\n                if (currentQuad == 4)\r\n                    camera.position.x += 10;\r\n                return false;\r\n            break;\r\n            case 'W':\r\n                if ((currentQuad == 1 || currentQuad == 4) && direction == 1)\r\n                    return true;\r\n                if ((currentQuad == 2 || currentQuad == 3) && direction == -1)\r\n                    return true;\r\n                if (currentQuad == 2)\r\n                    camera.position.z -= 10;\r\n                if (currentQuad == 3)\r\n                    camera.position.z += 10;\r\n                return false;\r\n            break;\r\n        }\r\n\r\n        return false;\r\n\r\n    }\r\n\r\n    return true;\r\n\r\n};\r\n\r\nMaze.prototype.checkWallCollision = function() {\r\n    \r\n    // figure out which cell player is in\r\n    var playerX = Math.floor(camera.position.x / this.cellSize) + (this.x/2);\r\n    var playerZ = Math.floor(camera.position.z / this.cellSize) + (this.y/2);\r\n\r\n    // mark cell as current cell if not already\r\n    if (playerX != this.playerCurrentCell[0] || playerZ != this.playerCurrentCell[1]) {\r\n        this.playerCurrentCell = [playerX, playerZ];\r\n        console.log('entered cell ' + playerX + ', ' + playerZ);\r\n    }\r\n\r\n    // get walls in current cell\r\n    var walls = this.map[this.playerCurrentCell[1]][this.playerCurrentCell[0]];\r\n\r\n    // get global boundary coords\r\n    var bounds = [];\r\n    bounds.push((this.playerCurrentCell[1] * this.cellSize - \r\n        ((this.y*this.cellSize)/2)) + this.collisionPadding);\r\n    bounds.push((this.playerCurrentCell[0] * this.cellSize - \r\n        ((this.x*this.cellSize)/2)) + this.cellSize - this.collisionPadding);\r\n    bounds.push((this.playerCurrentCell[1] * this.cellSize - \r\n        ((this.y*this.cellSize)/2)) + this.cellSize - this.collisionPadding);\r\n    bounds.push((this.playerCurrentCell[0] * this.cellSize - \r\n        ((this.x*this.cellSize)/2)) + this.collisionPadding);\r\n\r\n    \r\n    // test each wall for collision\r\n    var whichWall = false;\r\n\r\n    if (walls[0] && camera.position.z <= bounds[0]) {\r\n        console.log('hit north wall');\r\n        whichWall = 'N';\r\n    }\r\n    if (walls[1] && camera.position.x >= bounds[1]) {\r\n        console.log('hit east wall');\r\n        whichWall = 'E';\r\n    }\r\n    if (walls[2] && camera.position.z >= bounds[2]) {\r\n        console.log('hit south wall');\r\n        whichWall = 'S';\r\n    }\r\n    if (walls[3] && camera.position.x <= bounds[3]) {\r\n        console.log('hit west wall');\r\n        whichWall = 'W';\r\n    }\r\n\r\n    this.atWall = whichWall;\r\n};\r\n\r\nMaze.prototype.render = function(ctx) {\r\n    \r\n    var cell;\r\n    var cx;\r\n    var cy;\r\n\r\n    var geometry, texture, mesh;\r\n\r\n    // draw grass\r\n    geometry = new THREE.BoxGeometry(this.x*this.cellSize, 10, this.y*this.cellSize);\r\n    texture = THREE.ImageUtils.loadTexture('/static/site/img/textures/grass.jpg');\r\n    texture.anisotropy = renderer.getMaxAnisotropy();\r\n    material = new THREE.MeshBasicMaterial( { map: texture } );\r\n    this.grass = new THREE.Mesh( geometry, material );\r\n    this.grass.position.set(0, -100, 0); \r\n    scene.add( this.grass );\r\n\r\n    // draw sky\r\n    var skyRadius;\r\n    if (this.y > this.x) {\r\n        skyRadius = (this.y*this.cellSize);\r\n    } else skyRadius = (this.x*this.cellSize); \r\n    \r\n    geometry = new THREE.SphereGeometry(skyRadius, 16, 16, Math.PI/2,  Math.PI*2, 0, Math.PI);\r\n    texture = THREE.ImageUtils.loadTexture('/static/site/img/textures/sky.jpg');\r\n    texture.anisotropy = renderer.getMaxAnisotropy();\r\n    material = new THREE.MeshBasicMaterial( {map: texture} );\r\n    material.side = THREE.BackSide\r\n    this.sky = new THREE.Mesh(geometry, material);\r\n    this.sky.position.set(0,0,0);\r\n    scene.add(this.sky);\r\n\r\n    for (var i=0; i<this.y; i++) {\r\n        for (var j=0; j<this.x; j++) {\r\n            \r\n            cell = this.map[i][j];\r\n            cx = this.cellSize * j - ((this.x*this.cellSize)/2);\r\n            cy = this.cellSize * i - ((this.y*this.cellSize)/2);\r\n            var mt;\r\n            var lt;\r\n\r\n            if (cell[0]) {\r\n                mt = [cx, cy];\r\n                lt = [cx+this.cellSize, cy];\r\n                if (!this.wallIsRendered(mt, lt)) {\r\n                    geometry = new THREE.BoxGeometry(  200, 200, 10  );\r\n                    texture = THREE.ImageUtils.loadTexture('/static/site/img/textures/wood.jpg');\r\n                    texture.anisotropy = renderer.getMaxAnisotropy();\r\n                    material = new THREE.MeshBasicMaterial( { map: texture } );\r\n                    mesh = new THREE.Mesh( geometry, material );\r\n                    mesh.position.set(mt[0]+this.cellSize/2, 0, mt[1]); \r\n                    scene.add( mesh );\r\n                }\r\n            } \r\n            if (cell[1]) {\r\n                mt = [cx+this.cellSize, cy];\r\n                lt = [cx+this.cellSize, cy+this.cellSize];\r\n                if (!this.wallIsRendered(mt, lt)) {\r\n                    geometry = new THREE.BoxGeometry(  10, 200, 200  );\r\n                    texture = THREE.ImageUtils.loadTexture('/static/site/img/textures/wood.jpg');\r\n                    texture.anisotropy = renderer.getMaxAnisotropy();\r\n                    material = new THREE.MeshBasicMaterial( { map: texture } );\r\n                    mesh = new THREE.Mesh( geometry, material );\r\n                    mesh.position.set(mt[0], 0, mt[1]+this.cellSize/2); \r\n                    scene.add( mesh );\r\n                }\r\n            } \r\n            if (cell[2]) {\r\n                mt = [cx+this.cellSize, cy+this.cellSize];\r\n                lt = [cx, cy+this.cellSize];\r\n                if (!this.wallIsRendered(mt, lt)) {\r\n                    geometry = new THREE.BoxGeometry(  200, 200, 10  );\r\n                    texture = THREE.ImageUtils.loadTexture('/static/site/img/textures/crate.gif');\r\n                    texture.anisotropy = renderer.getMaxAnisotropy();\r\n                    material = new THREE.MeshBasicMaterial( { map: texture } );\r\n                    mesh = new THREE.Mesh( geometry, material );\r\n                    mesh.position.set(mt[0]-this.cellSize/2, 0, mt[1]); \r\n                    scene.add( mesh );\r\n                }\r\n            }\r\n            if (cell[3]) {\r\n                mt = [cx, cy+this.cellSize];\r\n                lt = [cx, cy];\r\n                if (!this.wallIsRendered(mt, lt)) {\r\n                    geometry = new THREE.BoxGeometry(  10, 200, 200  );\r\n                    texture = THREE.ImageUtils.loadTexture('/static/site/img/textures/crate.gif');\r\n                    texture.anisotropy = renderer.getMaxAnisotropy();\r\n                    material = new THREE.MeshBasicMaterial( { map: texture } );\r\n                    mesh = new THREE.Mesh( geometry, material );\r\n                    mesh.position.set(mt[0], 0, mt[1]-this.cellSize/2); \r\n                    scene.add( mesh );\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n};\r\n\r\nMaze.prototype.walkForward = function() {\r\n    this.checkWallCollision();\r\n    if (this.isDirectionValid(1)) {\r\n        camera.position.x -= 10 * Math.sin(camera.rotation.y);\r\n        camera.position.z += 10 * Math.cos(camera.rotation.y);\r\n        console.log('F');\r\n    }\r\n};\r\n\r\nMaze.prototype.walkBackwards = function() {\r\n    this.checkWallCollision();\r\n    if (this.isDirectionValid(-1)) {\r\n        camera.position.x += 10 * Math.sin(camera.rotation.y);\r\n        camera.position.z -= 10 * Math.cos(camera.rotation.y);\r\n        console.log('B');\r\n    }\r\n};\r\n\r\nMaze.prototype.turnLeft = function() {\r\n    camera.rotation.y -= Math.PI / 10;\r\n};\r\n\r\nMaze.prototype.turnRight = function() {\r\n    camera.rotation.y += Math.PI / 10;\r\n};\r\n\r\nMaze.prototype.flyUp = function() {\r\n    camera.position.y += 10;\r\n};\r\n\r\nMaze.prototype.flyDown = function() {\r\n    camera.position.y -= 10;\r\n};\r\n\r\n// } end class Maze\r\n\r\n/*\r\n    MazeSolver pseudo-code\r\n\r\n    1. start at the entrance\r\n    2. while not at the exit\r\n        1. push the current cell to visited\r\n        2. if exists one or more directions that have not been visited\r\n            1. push the current cell to pathStack\r\n            2. choose any direction from those not visited\r\n            3. move in that direction\r\n            4. draw path from previous cell to chosen cell\r\n            5. make the chosen cell the current cell\r\n        3. otherwise backtrack\r\n            1. pop the pathStack\r\n            2. remove line from currentCell to popped cell\r\n            3. do not remove popped cell from visited\r\n*/\r\n\r\n// class MazeSolver {\r\n\r\nfunction MazeSolver(maze) {\r\n    this.Maze = maze;\r\n    this.position = [0, 0];\r\n    this.pathStack = [];\r\n    this.visited = [];\r\n    this.Maze.clearBall();\r\n\r\n    var self = this;\r\n    this.solveStep = function() {\r\n        self.moveForward();\r\n    };\r\n}\r\n\r\nMazeSolver.prototype.getValidDirections = function(x,y) {\r\n    \r\n    var directions = [];\r\n    \r\n    if (!this.Maze.map[y][x][0]) \r\n        directions.push([0,-1]);\r\n    if (!this.Maze.map[y][x][1] && (x!=this.Maze.x-1 || y!=this.Maze.y-1)) \r\n        directions.push([1,0]);\r\n    if (!this.Maze.map[y][x][2]) \r\n        directions.push([0,1]);\r\n    if (!this.Maze.map[y][x][3] && (x||y)) \r\n        directions.push([-1,0]);\r\n\r\n    var validDirections = [];\r\n    for (var i=0; i<directions.length; i++) {\r\n        var tx = x+directions[i][0];\r\n        var ty = y+directions[i][1];\r\n        if (!this.isVisited(tx,ty)) {\r\n            validDirections.push(directions[i]);\r\n        }\r\n    }\r\n\r\n    return validDirections;\r\n};\r\n\r\nMazeSolver.prototype.isVisited = function(x,y) {\r\n    for (var i=0; i<this.visited.length; i++) {\r\n        if (this.visited[i][0] == x && this.visited[i][1] == y) \r\n            return true;\r\n    }\r\n    return false;\r\n};\r\n\r\nMazeSolver.prototype.isDeadEnd = function(x,y) {\r\n    if (!this.getValidDirections(x,y).length)\r\n        return true;\r\n    return false;\r\n};\r\n\r\nMazeSolver.prototype.movePath = function(cx,cy,nx,ny) {\r\n    ctx.lineWidth = 4;\r\n    ctx.strokeStyle = '#5555ff';\r\n    ctx.beginPath();\r\n\r\n    ctx.moveTo(cx*this.Maze.cellSize+this.Maze.cellSize/2, \r\n        cy*this.Maze.cellSize+this.Maze.cellSize/2);\r\n    ctx.lineTo(nx*this.Maze.cellSize+this.Maze.cellSize/2, \r\n        ny*this.Maze.cellSize+this.Maze.cellSize/2);\r\n    ctx.stroke();\r\n};\r\n\r\nMazeSolver.prototype.clearPath = function(x,y) {\r\n    ctx.clearRect(x*this.Maze.cellSize+2, y*this.Maze.cellSize+2, \r\n        this.Maze.cellSize-4, this.Maze.cellSize-4);\r\n};\r\n\r\nMazeSolver.prototype.isFinished = function() {\r\n    if (this.position[0] == this.Maze.x-1 && this.position[1] == this.Maze.y-1)\r\n        return true;\r\n    return false;\r\n};\r\n\r\nMazeSolver.prototype.moveForward = function() {\r\n    \r\n    var cx = this.position[0];\r\n    var cy = this.position[1];\r\n    \r\n    this.visited.push([cx,cy]);\r\n    \r\n    if (this.isFinished()) {\r\n        console.log("FINISH");\r\n        clearInterval(this.interval);\r\n        return;\r\n    }\r\n\r\n    if (!this.isDeadEnd(cx,cy)) {\r\n        this.pathStack.push([cx,cy]);\r\n        var directions = this.getValidDirections(cx,cy);\r\n        var randomDirection = Math.floor(Math.random()*directions.length);\r\n        \r\n        var nx = cx + directions[randomDirection][0];\r\n        var ny = cy + directions[randomDirection][1];\r\n\r\n        this.movePath(cx,cy,nx,ny);\r\n        this.position = [nx,ny];\r\n\r\n    } else { \r\n        this.backtrack();\r\n    }\r\n};\r\n\r\nMazeSolver.prototype.backtrack = function() {\r\n    var lastCell = this.pathStack.pop();\r\n    this.clearPath(this.position[0], this.position[1]);\r\n    this.position = [lastCell[0], lastCell[1]];\r\n};\r\n\r\n// } end class MazeSolver\r\n\r\n\r\n$(document).keydown(function(e) {\r\n    \r\n    var tx = Maze.currentPosition[0];\r\n    var ty = Maze.currentPosition[1];\r\n\r\n    switch (e.keyCode) {\r\n\r\n        case 37: // left\r\n            Maze.turnLeft();\r\n        break;\r\n        case 38: // up (forward)\r\n            Maze.walkForward();\r\n        break;\r\n        case 39: // right\r\n            Maze.turnRight();\r\n        break;\r\n        case 40: // down (backwards)\r\n            Maze.walkBackwards();\r\n        break;\r\n        case 65: // 'a' key\r\n            Maze.flyUp();\r\n        break;\r\n        case 90: // 'z' key\r\n            Maze.flyDown();\r\n        break;\r\n\r\n    }\r\n});\r\n\r\nfunction solveMaze() {\r\n    solver = new MazeSolver(Maze);\r\n    solver.interval = setInterval(solver.solveStep, 5);\r\n}\r\n\r\nvar Maze;\r\n\r\n\r\nvar ctx;\r\nvar solver;\r\n\r\nvar camera, scene, renderer;\r\nvar mesh;\r\n\r\nfunction onWindowResize() {\r\n\tcamera.aspect = window.innerWidth / window.innerHeight;\r\n\tcamera.updateProjectionMatrix();\r\n\trenderer.setSize( window.innerWidth, window.innerHeight );\r\n}\r\n\r\nfunction animate() {\r\n\trequestAnimationFrame(animate);\r\n\trenderer.render(scene, camera);\r\n}\r\n\r\n    \r\nvar cellSize = 200;\r\n\r\nrenderer = new THREE.WebGLRenderer({\r\n    preserveDrawingBuffer: true,\r\n});\r\nvar __renderer = $(renderer);\r\n\r\nrenderer.setSize( Canvas.width, Canvas.height );\r\nconsole.log(renderer.domElement); console.log('-----');\r\ndocument.body.appendChild( renderer.domElement );\r\n\r\nwindow._renderer = renderer;\r\n\r\ncamera = new THREE.PerspectiveCamera( 90, \r\n\twindow.innerWidth / window.innerHeight, 1, 10000 );\r\nscene = new THREE.Scene();\r\n\r\nMaze = new Maze(2, 16, 10, cellSize);\r\nMaze.render();\r\n\r\ncamera.position.x = Maze.cellSize * Maze.x * -0.5;\r\ncamera.position.y = 15;\r\ncamera.position.z = Maze.cellSize * Maze.y * -0.5 + Maze.cellSize/2;\r\n\r\ncamera.lookAt(scene.position);\r\nwindow.addEventListener( 'resize', onWindowResize, false );\r\nanimate();\r\n\r\nwindow.appdestroy = function() {\r\n\tconsole.log('domel', $(__renderer[0].domElement));\r\n\t$(__renderer[0].domElement).remove();\r\n\tdelete renderer;\r\n \tdelete __renderer;\r\n\twindow.removeEventListener('resize');\r\n}	{}		\N	2016-04-10 22:24:07.039821+00	46
28	Fractal Tree Creatures	Fractal trees and random plants and creatures.	2016-03-24 02:26:54.501906+00	3	1	text/coffeescript	#####################################\r\n#                                   #\r\n#   @author: Nino P. Cocchiarella   #\r\n#   Copyright (C) 2015              #\r\n#   plerp.org                       #\r\n#                                   #\r\n#####################################\r\n\r\npi = Math.PI\r\nabs = Math.abs\r\nsin = Math.sin\r\ncos = Math.cos\r\narcsin = Math.asin\r\narccos = Math.acos\r\narctan = Math.atan\r\nroot = Math.sqrt\r\n\r\n\r\nmoveTo = ([x,y]) -> gl.moveTo(x, y)\r\nlineTo = ([x,y]) -> gl.lineTo(x, y)\r\n\r\n# COLOR1 = "#785A3C"\r\n# COLOR2 = "#00aa00"\r\n# NUM_ITERATIONS = 6\r\n# TRAPEZOIDAL_SECTIONS = 20\r\n# CHILDREN = [3, -7, 6]\r\n# DEGREE1_COEFF = 17\r\n# DEGREE2_COEFF = 30\r\n\r\n\r\ngenerationChildCounts = _.map _.range(NUM_ITERATIONS+1), () -> 0\r\n\r\ncolorHex2rgb = (color) ->\r\n    col = color.split("#").join("")\r\n    _r = col.substr 0,2\r\n    _g = col.substr 2,2\r\n    _b = col.substr 4,2\r\n    return _.map [_r,_g,_b], (c) -> parseInt(c,16)\r\n\r\nclass TreeStick\r\n\r\n    rad2deg: (x) ->\r\n        return x * (180/pi)\r\n\r\n    constructor: (params) ->\r\n        {\r\n            @start,\r\n            @direction,\r\n            @length,\r\n            @start_alpha,\r\n            @begin_thickness,\r\n            @end_thickness,\r\n            @generation,\r\n            @children\r\n        } = params\r\n\r\n        #console.log 'sa', @start_alpha\r\n\r\n        @delta_thickness = (@begin_thickness - @end_thickness) / TRAPEZOIDAL_SECTIONS\r\n        @delta_length = @length / TRAPEZOIDAL_SECTIONS\r\n\r\n        @current_position = @start\r\n        @current_thickness = @begin_thickness\r\n\r\n        perp = @direction + pi/2\r\n\r\n        @current_edges = [\r\n            [@start[0] + (@begin_thickness/2)*(cos perp), @start[1] + (@begin_thickness/2)*(sin perp)],\r\n            [@start[0] - (@begin_thickness/2)*(cos perp), @start[1] - (@begin_thickness/2)*(sin perp)]\r\n        ]\r\n\r\n        @trapezoids = []\r\n        @left_edges = []\r\n        @right_edges = []\r\n        @directions = []\r\n        @left_directions = []\r\n        @right_directions = []\r\n\r\n\r\n        for i in [0...TRAPEZOIDAL_SECTIONS]\r\n\r\n            points = []\r\n            start_midpoint = @current_position\r\n\r\n            end_midpoint = [\\\r\n                (@current_position[0] + @delta_length * cos @direction), \\\r\n                (@current_position[1] + @delta_length * sin @direction)]\r\n\r\n            perp = @direction + pi/2\r\n            start_perp = [\\\r\n                (@current_position[0] + (@current_thickness/2) * cos perp),\\\r\n                (@current_position[1] + (@current_thickness/2) * sin perp)]\r\n            end_perp = [\\\r\n                (@current_position[0] - (@current_thickness/2) * cos perp),\\\r\n                (@current_position[1] - (@current_thickness/2) * sin perp)]\r\n\r\n\r\n            @current_position = end_midpoint\r\n            @current_thickness -= @delta_thickness\r\n\r\n\r\n            #####  main curve function\r\n            @direction -= (pi/DEGREE1_COEFF - i*(pi/DEGREE2_COEFF))\r\n            #console.log 'direction', @direction\r\n\r\n            #### sucessor\r\n\r\n            start_perp2 = [\\\r\n                (@current_position[0] + (@current_thickness/2) * cos perp),\\\r\n                (@current_position[1] + (@current_thickness/2) * sin perp)]\r\n            end_perp2 = [\\\r\n                (@current_position[0] - (@current_thickness/2) * cos perp),\\\r\n                (@current_position[1] - (@current_thickness/2) * sin perp)]\r\n\r\n            points.push @current_edges[0]\r\n            points.push @current_edges[1]\r\n            points.push end_perp2\r\n            points.push start_perp2\r\n\r\n            @left_edges.push [start_perp, start_perp2]\r\n            @right_edges.push [end_perp2, end_perp]\r\n\r\n            @directions.push @direction\r\n\r\n            dx = start_perp2[0] - start_perp[0]\r\n            dy = start_perp2[1] - start_perp[1]\r\n\r\n\r\n\r\n\r\n\r\n            left_direction = arctan (dy/dx)\r\n            @left_directions.push left_direction\r\n\r\n            dx = end_perp2[0] - end_perp[0]\r\n            dy = end_perp2[1] - end_perp[1]\r\n            right_direction = arctan (dy/dx)\r\n            @right_directions.push right_direction\r\n\r\n\r\n            @trapezoids.push points\r\n            @current_edges = [start_perp2, end_perp2]\r\n\r\n        #@draw()\r\n        ##console.log @left_directions, @right_directions, @directions\r\n\r\n        if @generation < NUM_ITERATIONS\r\n\r\n            for child_index in @children\r\n\r\n                if child_index < 0\r\n\r\n                    dx = @left_edges[abs(child_index)][1][0] - @left_edges[abs(child_index)][0][0]\r\n                    dy = @left_edges[abs(child_index)][1][1] - @left_edges[abs(child_index)][0][1]\r\n                    midpoint = [\\\r\n                        (@left_edges[abs(child_index)][1][0] + @left_edges[abs(child_index)][0][0]) / 2,\r\n                        (@left_edges[abs(child_index)][1][1] + @left_edges[abs(child_index)][0][1]) / 2\r\n                    ]\r\n\r\n                    #if @generation == 0\r\n                    ##console.log start_perp, start_perp2\r\n                        #console.log dx, dy\r\n\r\n                if child_index > 0\r\n\r\n                    dx = @right_edges[abs(child_index)][1][0] - @right_edges[abs(child_index)][0][0]\r\n                    dy = @right_edges[abs(child_index)][1][1] - @right_edges[abs(child_index)][0][1]\r\n                    midpoint = [\\\r\n                        (@right_edges[abs(child_index)][1][0] + @right_edges[abs(child_index)][0][0]) / 2,\r\n                        (@right_edges[abs(child_index)][1][1] + @right_edges[abs(child_index)][0][1]) / 2\r\n                    ]\r\n\r\n\r\n\r\n                # get length of edge\r\n                edge_length = root (dx**2 + dy**2)\r\n\r\n                # get angle\r\n                theta = @left_directions[abs(child_index)] - (pi/2) if child_index < 0\r\n                theta = @right_directions[abs(child_index)] + (pi/2) if child_index > 0\r\n                ##console.log @rad2deg(theta)\r\n\r\n                #console.log @generation\r\n                start_alpha = (1 - 0.1* @generation)\r\n                #console.log 'sa', start_alpha\r\n\r\n                babyTreeStick =\r\n                    start: midpoint\r\n                    direction: theta\r\n                    length: @length * ((TRAPEZOIDAL_SECTIONS-abs(child_index))/TRAPEZOIDAL_SECTIONS)\r\n                    start_alpha: 1 - 0.1* @generation\r\n                    begin_thickness: edge_length\r\n                    end_thickness: edge_length * (@end_thickness/@begin_thickness)\r\n                    generation: @generation + 1\r\n                    children: @children\r\n\r\n                baby = new TreeStick babyTreeStick\r\n                \r\n                \r\n\r\n        #else\r\n        #    for child_index in @children\r\n        #        gl.fillStyle = '#0000cc'\r\n        #        gl.beginPath()\r\n        #        gl.arc(@left_edges[abs(child_index)][1][0], @left_edges[abs(child_index)][1][1], 2, 0, 2*pi, false)\r\n        #        gl.fill()\r\n\r\n        @draw()\r\n\r\n\r\n\r\n    draw: ->\r\n\r\n        generationChildCounts[@generation]++\r\n\r\n        for trap in @trapezoids\r\n            gl.strokeStyle = '#111111'\r\n            gl.lineWidth = 1\r\n            [r,g,b] = colorHex2rgb COLOR1\r\n            gl.fillStyle = "rgba(#{r},#{g},#{b},#{@start_alpha})"\r\n            if @generation == NUM_ITERATIONS\r\n                gl.strokeStyle = COLOR2\r\n            gl.beginPath()\r\n            moveTo trap[0]\r\n            lineTo trap[1]\r\n            lineTo trap[2]\r\n            lineTo trap[3]\r\n            gl.closePath()\r\n            gl.stroke()\r\n            gl.fill()\r\n        \r\n        if @generation == NUM_ITERATIONS and generationChildCounts[NUM_ITERATIONS] == Math.pow @children.length, NUM_ITERATIONS\r\n            try\r\n                window.renderingDone()\r\n            catch e\r\n                console.log e\r\n\r\n\r\n\r\n\r\ngl = null\r\n\r\n$(document).ready ->\r\n\r\n    #Canvas = document.getElementById('big-canvas')\r\n\r\n    gl = Canvas.getContext('2d')\r\n\r\n    Canvas.width = $(window).width()\r\n    Canvas.height = $(window).height()\r\n\r\n    \r\n    gl.scale(1, -1)\r\n    gl.translate(0, -Canvas.height)\r\n    U_width = Canvas.width\r\n    U_height = Canvas.height\r\n\r\n    originalTreeStick =\r\n        start: [U_width/2, 0]\r\n        direction: pi/2\r\n        length: U_height\r\n        start_alpha: 1\r\n        begin_thickness: 130\r\n        end_thickness: 20\r\n        generation: 0\r\n        children: CHILDREN\r\n\r\n    #console.log originalTreeStick\r\n\r\n    @hank = new TreeStick originalTreeStick\r\n    #@hank.draw()\r\n    #@frameInterval = setInterval (=> @hank.grow()), 100	{\r\n\t"COLOR1": {"type": "color", "default": "#785A3C"},\r\n\t"COLOR2": {"type": "color", "default": "#00AA00"},\r\n  \t"NUM_ITERATIONS":{"type": "number", "default":5, "min": 2, "max": 13},\r\n\t"CHILDREN": {"type": "javascript", "default": "[6,-7,8,12]"},\r\n\t"TRAPEZOIDAL_SECTIONS": {"type": "number", "default":15, "min": 5, "max": 50},\r\n\t"DEGREE1_COEFF": {"type": "number", "default":17, "min": 1, "max": 1000},\r\n\t"DEGREE2_COEFF": {"type": "number", "default":30, "min": 1, "max": 1000}\r\n}		\N	2016-04-09 17:55:58.086863+00	90
27	Plain Function in 1 variable	Creates the graphs of functions in 1 variable.  Allows you to enter your own function and range.	2016-03-23 11:27:56.498377+00	5	1	text/paperscript	// require cartesian axes\r\n// require MFunction\r\n\r\ndrawAxes(project.activeLayer);\r\n\r\nl = new Layer({\r\n\tblendMode: 'multiply'\r\n});\r\n\r\n// add function wrapper around js expression from math object\r\nvar mkfunc = "var _func1 = function(x) { return " + func1.javascript + "; }";\r\nconsole.log(mkfunc);\r\neval(mkfunc);\r\nvar F0 = new MFunction(_func1, [x_min, x_max]);\r\n\r\npath1 = new Path({\r\n    strokeColor: new Color(0.7, 0.3, 0.3, 0.8),\r\n    strokeWidth: 3,\r\n    closed: false,\r\n    //fillColor: new Color(Math.random(),1,Math.random(),0.2),\r\n});\r\nF0.compute();\r\n\r\ntransformation = [\r\n  [1, 0, 0], //5*Math.cos(Math.PI/-4)],\r\n  [0, 1, 0] //5*Math.sin(Math.PI/-4)],\r\n];\r\n\r\nF0.draw(path1);\r\npath1.smooth();	{\r\n  "func1":{"type": "math", \r\n\t"default":{\r\n\t  \t"latex":"x \\\\cos{\\\\left (x \\\\right )}",\r\n\t\t"javascript":"x*Math.cos(x)",\r\n\t\t"type":"math",\r\n\t\t"string":"x cos(x)",\r\n\t\t  "value":"x cos(x)"}},\r\n  "x_min":{"type": "number", "default":-5},\r\n  "x_max":{"type": "number", "default":5}\r\n}		\N	2016-04-09 17:57:04.461132+00	20
33	Bivariate Polynomial Landscape	Choose coefficients of high-degree a polynomial function in 2 variables, as well as the 3x3 matrix used to project the graph of the surface onto a 2-dimensional canvas.  Many intricate and beautiful scenes emerge with certain affine transformations.  Defaults to a "standard" parallel projection of the z-axis (the axis "coming out of the screen")	2016-04-05 01:19:50.444524+00	2	1	text/paperscript	view.viewSize = new Size(Canvas.width, Canvas.height);\n\nvar coeffs = _.mapObject(seed, function(val,key) {\n    return val.value;\n});\n\nvar polynomial_string = _.reduce(\n    _.filter(_.map(_.pairs(coeffs), function(coeff) {\n        var s = coeff[1] == 1 ? coeff[0].toString() : \t\n\t\t\tcoeff[1].toString()+coeff[0];\n        if (coeff[1] == 0) s = '';\n        return s;\n    }), function(x) {\n        return x != '';\n    }), function(a,b) {\n        var r = a;\n        var bnum = parseInt(b.replace(/[^0-9\\-]*/, '')) || 1;\n        r += (bnum > 0 ? '+'+b : b);\n        return r;\n    }, '');\n\nif (polynomial_string.substr(0,1) == '+') {\n    polynomial_string = polynomial_string.substr(1, polynomial_string.length);\n}\n\n\n\nDARK_GREY = new Color(0.3, 0.3, 0.3, 0.8);\nLIGHT_GREY = new Color(0.9, 0.9, 0.9, 0.2);\n\nx_axis = new Path({ strokeColor: DARK_GREY, strokeWidth: 0.3, strokeScaling: false });\nx_axis.add(new Point(-view.size.width/2, 0));\nx_axis.add(new Point(view.size.width/2, 0));\nx_axis.closed = true;\n//project.activeLayer.insertChild(0,x_axis)\n\ny_axis = new Path({ strokeColor: DARK_GREY, strokeWidth: 0.3, strokeScaling: false });\ny_axis.add(new Point(0, -view.size.height/2));\ny_axis.add(new Point(0, view.size.height/2));\n\nx_lines = [];\n_.each(_.range(-10,10), function(n) {\n    line = new Path({strokeColor: LIGHT_GREY });\n    line.add( new Point(n, view.size.height/2) );\n    line.add( new Point(n, -view.size.height/2) );\n    line.closed = true;\n    //project.activeLayer.insertChild(0, line);\n    x_lines.push( line );\n});\n\ny_lines = [];\n_.each(_.range(-10,10), function(n) {\n    line = new Path({strokeColor: LIGHT_GREY });\n    line.add( new Point(view.size.width/2, n) );\n    line.add( new Point(-view.size.width/2, n) );\n    line.closed = true;\n    //project.activeLayer.insertChild(0, line);\n    y_lines.push( line );\n});\n\nfunction transformToCartesian(lay) {\n    lay.transform( new Matrix((view.size.width / 10),0,0,(view.size.height / -10), view.center.x, view.center.y) );\n}\n\ntransformToCartesian(project.activeLayer);\n\n\n// define formal mathematical function\nMFunction = function(func, extrema) {\n    //console.log(func.length);\n    this.func = func;\n    if (!extrema) { extrema = [-5,5]; }\n\n    this.domain = {\n        elements: [],\n        min: (extrema[0] || -5),\n        max: (extrema[1] || 5)\n    };\n\n    this.codomain = {\n        elements: [],\n        min: null,\n        max: null\n    };\n\n    this.mapping = null;\n}\n\nMFunction.prototype = {\n    \n    compute: function(delta) {\n        if (!delta) { delta = 50; }\n        this.domain.elements = numeric.linspace(this.domain.min, this.domain.max, delta);\n        this.codomain.elements = _.map(this.domain.elements, this.func);\n        this.codomain.min = _.min(this.codomain.elements);\n        this.codomain.max = _.max(this.codomain.elements);\n        this.mapping = _.zip(this.domain.elements, this.codomain.elements);\n\n        this._w = Math.abs(this.domain.max - this.domain.min);\n        this._h = _.max(  [Math.abs(this.codomain.max),  Math.abs(this.codomain.min)]  );\n\n        this.transformation_matrix = new Matrix(\n            (view.size.width / this._w), 0,\n            0, (view.size.height / (-1*this._h)), \n            view.center.x, view.center.y);\n\n        this.computed = true;\n        console.log("computed")\n    },\n\n    // "flattens" mapping\n    // i.e. [[1,2],3] -> [1,2,3]\n    getPoints: function() {\n        if (!this.computed) { this.compute(); }\n        this.points = _.map(this.mapping, function(pair) {\n            return _.flatten(pair);\n        });\n        return this.points;\n    },\n\n\n    draw: function(path, matrix_premult, map3d, tmatrix) {\n\n        if (!this.computed) { this.compute(); }\n\n        if (map3d) {\n            this.points = this.points3d;\n        } else {\n            this.points = this.getPoints();\n        }\n\n        if (matrix_premult) {\n            this.points = _.map(this.points, function(p) {\n                return numeric.dot(matrix_premult, p);\n            })\n        }\n\n        _.each(this.points, function(p) {\n            path.add(new Point(p));\n        })\n\n        path.add(new Point(this.domain.max*2, Math.abs(this.codomain.min)*-5 + Math.abs(this.codomain.max)*-5));\n        path.add(new Point(this.domain.min*2, Math.abs(this.codomain.min)*-5 + Math.abs(this.codomain.max)*-5));\n        path.closed = true;\n\n        if (tmatrix) {\n            path.transform(tmatrix);\n        } else {\n            path.transform(this.transformation_matrix);\n        } \n    }\n}\n\nvar PolynomialObj = {};\n$.post("/symbolic_math/latex/", {\n    expressionString: polynomial_string\n}, function(data) {\n  \n    PolynomialObj = data;\n    console.log(PolynomialObj)\n    startRendering();\n  \n  \ttokens = PolynomialObj.latex.split(" ");\n\tline_length = Math.ceil(tokens.length/2);\n\tline2 = tokens.splice(-1*line_length).join(" ");\n\tline1 = tokens.join(" ");\n\n\ttry {\n      var text = [\n\t\t'Polynomial:<br />', \n\t\t"$" + line1 + "\\\\\\\\\\n\\\\space \\\\space \\\\space \\\\space " \n            + line2 + "$",\n\t\t'<div style="margin-top: 15px;">Projection Matrix:</div>',\n        "$\\\\left(\\\\begin{array}{rrr}1 & 0 & \\\\frac{1}{2}\\\\sqrt{2}\\\\\\\\\\n 0 & 1 & \\\\frac{1}{2}\\\\sqrt{2}\\\\end{array}\\\\right)$"];\n      var css = {"font-size":"11px", "color:":"#888888", "background-color": "rgba(230,230,230,0.7)"};\n      window.featureDisplay(text, css);\n    } catch (e) { console.log(e); }\n  \n});\n\nvar Polynomial = function(x,y) {\n    eval("var r = " + PolynomialObj.javascript + ";");\n    return r;\n}\n\nvar polynomial_degree = 5;\nvar zindex = undefined;\n\nfunction startRendering() {\n\n    slices = [];\n    zrange = [-15,0];\n    xrange = [-9, 9];\n    zspace = numeric.linspace(zrange[0], zrange[1], 50);\n\n    F0 = function(x) { return Polynomial(x,0); }\n    slice0 = new MFunction(F0, [xrange[0],xrange[1]]);\n    slice0.compute();\n    global_matrix = slice0.transformation_matrix;\n\n    CartesianMatrix = new Matrix(1,0,0,-1, view.center.x, view.center.y);\n\n    // begin drawing process\n    GraphLayer = new Layer({\n         blendMode: "multiply",\n    });\n\n    console.log("global matrix"); console.log(global_matrix);\n\n    function_shown = false;\n    zindex = 0;\n\n}\n\nview.onFrame = function(event) {\n    \n    if (zindex != undefined && zindex < zspace.length) {\n        \n        l = new Layer({\n            //blendMode: "multiply"\n        });\n\n        z = zspace[zindex];\n    \n        F = function(x) { return Polynomial(x,z); }\n        slice = new MFunction(F, [xrange[0],xrange[1]]);\n\n        points3d = slice.getPoints();\n        _.each(_.range(points3d.length), function(i) { points3d[i].push(z); });\n\n        slice.points3d = points3d\n\n        transformation = [\n            [1, 0, 0], //5*Math.cos(Math.PI/-4)],\n            [0, 1, 0] //5*Math.sin(Math.PI/-4)],\n        ];\n\n        path1 = new Path({\n            strokeColor: new Color(0.3, 0.3, 0.3, 0.5),\n            strokeWidth: 1,\n            closed: true,\n            fillColor: new Color(Math.random(),1,Math.random(),0.2),\n        });\n\n        slice.draw(path1, transformation, true, global_matrix);\n        //path.transform(CartesianMatrix)\n\n        // transformation2 = new Matrix(\n        //     1-(z/50), 0, 0, 1-(z/50), 0, 0 //5*Math.sin(Math.PI/-4)],\n        // );\n\n        transformation2 = new Matrix(\n            1, 0, 0, 1, 0, 0 //5*Math.sin(Math.PI/-4)],\n        );\n\n        //path1.transform(transformation2);\n        path1.scale(1-(z/50), 1-(z/50), view.center)\n        path1.translate(new Point(-10*z, 30*z))\n        \n        project.activeLayer.insertChild(0,path1);\n\n        slices.push({layer: project.activeLayer,\n            func: slice,\n            transformation: transformation,\n            path: path1});\n\n        if (zindex == zspace.length-1) { \n            //console.log(slices);\n            //view.pause();\n        }\n        zindex++;\n\n    }\n    \n}	{\n    "y":{"type":"number","default":1,"varname":"y"},\n    "y^2":{"type":"number","default":2,"varname":"y2"},\n    "y^3":{"type":"number","default":3,"varname":"y3"},\n    "y^4":{"type":"number","default":-2,"varname":"y4"},\n    "y^5":{"type":"number","default":5,"varname":"y5"},\n    "x":{"type":"number","default":1,"varname":"x"},\n    "xy":{"type":"number","default":1,"varname":"xy"},\n    "xy^2":{"type":"number","default":0,"varname":"xy2"},\n    "xy^3":{"type":"number","default":7,"varname":"xy3"},\n    "xy^4":{"type":"number","default":1,"varname":"xy4"},\n    "x^2":{"type":"number","default":1,"varname":"x2"},\n    "x^2y":{"type":"number","default":1,"varname":"x2y"},\n    "x^2y^2":{"type":"number","default":-13,"varname":"x2y2"},\n    "x^2y^3":{"type":"number","default":1,"varname":"x2y3"},\n    "x^3":{"type":"number","default":1,"varname":"x3"},\n    "x^3y":{"type":"number","default":0,"varname":"x3y"},\n    "x^3y^2":{"type":"number","default":1,"varname":"x3y2"},\n    "x^4":{"type":"number","default":1,"varname":"x4"},\n    "x^4y":{"type":"number","default":-5,"varname":"x4y"},\n    "x^5":{"type":"number","default":3,"varname":"x5"}\n}		\N	2016-04-12 00:38:22.710166+00	250
36	Subgroups of additive groups of integers mod(n)	Subgroups of additive groups of integers mod(n)	2016-04-10 03:25:56.53024+00	6	1	text/paperscript	view.viewSize = new Size(Canvas.width, Canvas.height);\n\nfunction get_divisors(n) {\n\treturn _.filter(_.range(1,n+1), function(i) {\n\t\treturn n%i==0;\n\t})\n}\n\nfunction isPrime(n) {\n\tif (n==1) \n\t\treturn false;\n\tfor (var i=2; i<n; i++) {\n\t\tif (n%i == 0) \n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nfunction is_member(x, rows) {\n\treturn _.includes(_.flatten(rows), x);\n}\n\nfunction subgroups(n) {\n\n\tvar rows = [[1]].concat([\n\t\t_.filter( _.range(1, Math.floor(n/2)), function(i) {\n\t\t\treturn n%i == 0 && isPrime(i);\n\t\t})\n\t]);\n\n\twhile (1) {\n\n\t\tvar newrow = [];\n\t\t_.each(rows[rows.length-1], function(element) {\n\t\t\t_.each(_.range(1, rows.length), function(prev_index) {\n\n\t\t\t\tvar prevrow = rows[prev_index];\n\t\t\t\t_.each(prevrow, function(e2) {\n\t\t\t\t\tvar m = element * e2;\n\t\t\t\t\tif (newrow.length > 0 && m == n) \n\t\t\t\t\t\treturn;\n\t\t\t\t\tif (n%m==0 && !is_member(m,rows) && !_.includes(newrow, m)) {\n\t\t\t\t\t\t_.each(newrow, function(ne) {\n\t\t\t\t\t\t\tif (ne > m && ne % m == 0) \n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t})\n\t\t\t\t\t\tnewrow.push(m);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t\t\n\t\tif (newrow.length == 0)\n\t\t\tbreak;\n\n\t\tvar newrow_relprime = newrow.sort(function(a,b) { return a - b; });\n\t\trows.push(newrow_relprime);\n\n\t}\n\n\treturn rows.reverse();\n}\n\n\nvar color1 = new Color({\n\thue: 350,\n\tsaturation: 0.1,\n\tbrightness: 0.9\n});\n\n\nif (isPrime(integer_group)) {\n\n\tvar circ = new Path.Circle({\n\t\tcenter: view.center,\n\t\tradius: 100,\n\t\tfillColor: color1\n\t});\n\n\tvar text = new PointText({\n\t    point: view.center,\n\t    justification: 'center',\n\t    content: integer_group.toString(),\n\t    fillColor: 'black',\n\t    fontFamily: 'Courier New',\n\t    fontWeight: 'bold',\n\t    fontSize: 32\n\t});\n\n\tvar text = new PointText({\n\t    point: new Point(view.center.x, view.center.y + 25),\n\t    justification: 'center',\n\t    content: 'prime',\n\t    fillColor: 'black',\n\t    fontFamily: 'Courier New',\n\t    fontSize: 14\n\t});\n\n} else {\n\n\tS = subgroups(integer_group);\n\tvar positions = {};\n\n\tvar rowheight = view.viewSize._height / S.length;\n\t_.each(S, function(row, i) {\n\n\t\tvar centerY = (rowheight*i) + (rowheight/2);\n\t\tvar colwidth = view.viewSize._width / row.length;\n\n\t\t_.each(row, function(num, j) {\n\n\t\t\tvar centerX = (colwidth*j) + (colwidth/2);\n\t\t\tvar center1 = new Point(centerX, centerY);\n\t\t\tvar center2 = new Point(centerX, (centerY+4));\n\n\t\t\tpositions[num.toString()] = [centerX, centerY];\n\n\t\t\tvar circ = new Path.Circle({\n\t\t\t\tcenter: center1,\n\t\t\t\tradius: 20,\n\t\t\t\tfillColor: color1\n\t\t\t});\n\n\t\t\tvar text = new PointText({\n\t\t\t    point: center2,\n\t\t\t    justification: 'center',\n\t\t\t    content: num.toString(),\n\t\t\t    fillColor: 'black',\n\t\t\t    fontFamily: 'Courier New',\n\t\t\t    fontWeight: 'bold',\n\t\t\t    fontSize: 16\n\t\t\t});\n\t\t})\n\t\t\n\t});\n\n\tvar divisors = get_divisors(integer_group);\n\tvar _S = S.reverse();\n\n\t_.each(divisors, function(div) {\n\t\t_.each(_S, function(row, i) {\n\t\t\t_.each(row, function(num) {\n\t\t\t\tif (div == num) {\n\t\t\t\t\tif (_S.length > i+1) {\n\t\t\t\t\t\tvar nextrow = _S[i+1];\n\t\t\t\t\t\tvar factors = [];\n\t\t\t\t\t\t_.each(nextrow, function(j) {\n\t\t\t\t\t\t\tif (j%div==0) {\n\t\t\t\t\t\t\t\tfactors.push(j);\n\t\t\t\t\t\t\t\tvar line = new Path.Line({\n\t\t\t\t\t\t            strokeColor: new Color(0.4,0.4,0.4,0.75),\n\t\t\t\t\t\t            strokeWidth: 1,\n\t\t\t\t\t\t            from: positions[num.toString()],\n\t\t\t\t\t\t            to: positions[j.toString()]\n\t\t\t\t\t\t        });\n\t\t\t\t\t\t        project.activeLayer.insertChild(0,line);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t});\n\n}\n\nvar renderDone = false;\nview.onFrame = function(e) {\n\tif (!renderDone && view.isVisible() && view.isInserted()) {\n\t  \trenderDone = true;\n\t \twindow.renderingDone(); \n\t}\n}\n\ntry {\n    window.featureDisplay("$\\\\{H\\: H \\\\leqslant (\\\\mathbb{Z}/" + \n    \tinteger_group + "\\\\space \\\\mathbb{Z})\\\\}$", {"font-size":"18px"});\n} catch (e) {}	{\n  "integer_group": {"type":"number", "default":840, "min":2, "max":99999999999}\n}		\N	2016-04-10 04:17:03.393174+00	300
\.


--
-- Name: game_plerpingapp_pkey; Type: CONSTRAINT; Schema: public; Owner: ninopq; Tablespace: 
--

ALTER TABLE ONLY game_zeroplayergame
    ADD CONSTRAINT game_plerpingapp_pkey PRIMARY KEY (id);


--
-- Name: game_plerpingapp_5e7b1936; Type: INDEX; Schema: public; Owner: ninopq; Tablespace: 
--

CREATE INDEX game_plerpingapp_5e7b1936 ON game_zeroplayergame USING btree (owner_id);


--
-- Name: game_plerpingapp_b583a629; Type: INDEX; Schema: public; Owner: ninopq; Tablespace: 
--

CREATE INDEX game_plerpingapp_b583a629 ON game_zeroplayergame USING btree (category_id);


--
-- Name: game_zeroplayergame_6be37982; Type: INDEX; Schema: public; Owner: ninopq; Tablespace: 
--

CREATE INDEX game_zeroplayergame_6be37982 ON game_zeroplayergame USING btree (parent_id);


--
-- Name: game_plerpingapp_owner_id_db15314c_fk_authtools_user_id; Type: FK CONSTRAINT; Schema: public; Owner: ninopq
--

ALTER TABLE ONLY game_zeroplayergame
    ADD CONSTRAINT game_plerpingapp_owner_id_db15314c_fk_authtools_user_id FOREIGN KEY (owner_id) REFERENCES authtools_user(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: game_zeroplayergam_parent_id_00669d04_fk_game_zeroplayergame_id; Type: FK CONSTRAINT; Schema: public; Owner: ninopq
--

ALTER TABLE ONLY game_zeroplayergame
    ADD CONSTRAINT game_zeroplayergam_parent_id_00669d04_fk_game_zeroplayergame_id FOREIGN KEY (parent_id) REFERENCES game_zeroplayergame(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: game_zeroplayergame_category_id_421feca0_fk_game_category_id; Type: FK CONSTRAINT; Schema: public; Owner: ninopq
--

ALTER TABLE ONLY game_zeroplayergame
    ADD CONSTRAINT game_zeroplayergame_category_id_421feca0_fk_game_category_id FOREIGN KEY (category_id) REFERENCES game_category(id) DEFERRABLE INITIALLY DEFERRED;


--
-- PostgreSQL database dump complete
--

